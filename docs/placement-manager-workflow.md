# PlacementManager 工作流程

## 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        PlacementManager                         │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                    place(positions)                        │ │
│  └───────────────────────────────────────────────────────────┘ │
│                              │                                  │
│                              ▼                                  │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ 步骤 1: 验证位置 (canPlaceBlock)                           │ │
│  │  • 检查是否越界                                            │ │
│  │  • 检查是否已被占用                                        │ │
│  └───────────────────────────────────────────────────────────┘ │
│                              │                                  │
│                    ┌─────────┴──────────┐                      │
│                    │                    │                      │
│                 失败 ✗               成功 ✓                     │
│                    │                    │                      │
│                    ▼                    ▼                      │
│  ┌─────────────────────┐  ┌──────────────────────────────────┐│
│  │ 返回失败结果         │  │ 步骤 2: 放置方块 (placeBlock)     ││
│  │  success: false     │  │  • 更新棋盘状态                   ││
│  │  score: 0           │  └──────────────────────────────────┘│
│  │  reason: "原因"     │               │                       │
│  └─────────────────────┘               ▼                       │
│                         ┌──────────────────────────────────┐   │
│                         │ 步骤 3: 检测满行/列               │   │
│                         │  • getFullRows()                 │   │
│                         │  • getFullColumns()              │   │
│                         └──────────────────────────────────┘   │
│                                        │                       │
│                                        ▼                       │
│                         ┌──────────────────────────────────┐   │
│                         │ 步骤 4: 消除满行/列               │   │
│                         │  • clearRows(fullRows)           │   │
│                         │  • clearColumns(fullColumns)     │   │
│                         └──────────────────────────────────┘   │
│                                        │                       │
│                                        ▼                       │
│                         ┌──────────────────────────────────┐   │
│                         │ 步骤 5: 计算得分                  │   │
│                         │  • 基础分 (格子数 × 每格分)       │   │
│                         │  • 消除分 (线数 × 每线分)         │   │
│                         │  • 连消奖励 (≥2条线时)           │   │
│                         └──────────────────────────────────┘   │
│                                        │                       │
│                                        ▼                       │
│                         ┌──────────────────────────────────┐   │
│                         │ 返回成功结果                      │   │
│                         │  success: true                   │   │
│                         │  clearedRows: [...]              │   │
│                         │  clearedColumns: [...]           │   │
│                         │  score: 计算结果                  │   │
│                         └──────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## 得分计算流程

```
输入: cellCount (格子数), rowCount (消行数), columnCount (消列数)

┌─────────────────────────────┐
│ 步骤 1: 计算基础分           │
│ baseScore = cellCount × 1   │
└─────────────┬───────────────┘
              │
              ▼
┌─────────────────────────────┐
│ 步骤 2: 计算总线数           │
│ totalLines = rowCount +     │
│              columnCount    │
└─────────────┬───────────────┘
              │
         totalLines > 0 ?
              │
      ┌───────┴────────┐
      │                │
     否               是
      │                │
      │                ▼
      │   ┌────────────────────────────┐
      │   │ 步骤 3: 计算消除分          │
      │   │ lineScore =                │
      │   │   totalLines × 10          │
      │   └────────────┬───────────────┘
      │                │
      │                ▼
      │           totalLines ≥ 2 ?
      │                │
      │        ┌───────┴────────┐
      │        │                │
      │       否               是
      │        │                │
      │        │                ▼
      │        │   ┌────────────────────────────┐
      │        │   │ 步骤 4: 计算连消奖励         │
      │        │   │ comboBonus = lineScore ×   │
      │        │   │   (totalLines - 1) × 0.5   │
      │        │   └────────────┬───────────────┘
      │        │                │
      ▼        ▼                ▼
┌─────────────────────────────────────┐
│ 步骤 5: 汇总                         │
│ totalScore = baseScore +            │
│              lineScore +            │
│              comboBonus             │
└─────────────┬───────────────────────┘
              │
              ▼
         返回 totalScore
```

## 示例场景

### 场景 1: 简单放置（无消除）

```
输入: 
  positions = [{row:0, col:0}, {row:0, col:1}, {row:0, col:2}]

流程:
  1. 验证 ✓ → 位置有效且未占用
  2. 放置 ✓ → 更新棋盘 3 格
  3. 检测   → 无满行/列
  4. 消除   → 无需消除
  5. 计分   → 3 × 1 = 3

输出:
  {
    success: true,
    clearedRows: [],
    clearedColumns: [],
    score: 3
  }
```

### 场景 2: 触发单行消除

```
输入: 
  棋盘第 0 行已有 8 格
  positions = [{row:0, col:8}]  // 最后一格

流程:
  1. 验证 ✓ → 位置有效
  2. 放置 ✓ → 更新棋盘 1 格
  3. 检测   → 发现满行 [0]
  4. 消除 ✓ → 清除第 0 行
  5. 计分   → 1 + (1 × 10) = 11

输出:
  {
    success: true,
    clearedRows: [0],
    clearedColumns: [],
    score: 11
  }
```

### 场景 3: 连消奖励（2条线）

```
输入:
  棋盘第 4 行差 1 格，第 4 列差 1 格
  positions = [{row:4, col:4}]  // 中心点

流程:
  1. 验证 ✓ → 位置有效
  2. 放置 ✓ → 更新棋盘 1 格
  3. 检测   → 发现满行 [4], 满列 [4]
  4. 消除 ✓ → 清除第 4 行和第 4 列
  5. 计分:
     - 基础: 1 × 1 = 1
     - 消除: 2 × 10 = 20
     - 连消: 20 × (2-1) × 0.5 = 10
     - 总计: 1 + 20 + 10 = 31

输出:
  {
    success: true,
    clearedRows: [4],
    clearedColumns: [4],
    score: 31
  }
```

### 场景 4: 放置失败

```
输入:
  棋盘 (0,0) 已被占用
  positions = [{row:0, col:0}]

流程:
  1. 验证 ✗ → 位置已占用
  2. 返回失败

输出:
  {
    success: false,
    clearedRows: [],
    clearedColumns: [],
    score: 0,
    reason: "Position occupied"
  }
```

## 类依赖关系

```
┌──────────────────┐
│     Board        │  提供棋盘操作
│                  │  • canPlaceBlock()
│  - grid[][]      │  • placeBlock()
│  - size          │  • getFullRows()
│                  │  • getFullColumns()
│                  │  • clearRows()
│                  │  • clearColumns()
└────────┬─────────┘
         │ 依赖
         │
         ▼
┌──────────────────┐
│ PlacementManager │  放置流程管理
│                  │
│  - board         │  • place()
│  - scoreConfig   │  • calculateScore()
│                  │  • getScoreConfig()
│                  │  • updateScoreConfig()
└──────────────────┘
         ▲
         │ 使用
         │
┌────────┴─────────┐
│   游戏控制器      │  游戏逻辑
│                  │
│  - manager       │  管理游戏状态
│  - totalScore    │  处理玩家操作
└──────────────────┘
```

## 状态转换图

```
棋盘状态转换:

┌─────────────┐
│   空棋盘     │
└──────┬──────┘
       │ place()
       ▼
┌─────────────┐
│  部分占用    │ ◄────┐
└──────┬──────┘      │ 继续 place()
       │             │
       │ place() + 触发消除
       ▼             │
┌─────────────┐      │
│  检测满行/列 │      │
└──────┬──────┘      │
       │             │
       │ clearRows/Columns
       ▼             │
┌─────────────┐      │
│  消除后状态  │──────┘
└─────────────┘
```

## 性能考虑

- **时间复杂度**:
  - 验证位置: O(n), n = positions.length
  - 放置方块: O(n)
  - 检测满行: O(size) = O(9)
  - 检测满列: O(size²) = O(81)
  - 清除行列: O(size × lines)
  - **总计**: O(n + size²) ≈ O(81) 常量时间

- **空间复杂度**: O(1) - 只使用少量临时变量

## 扩展性

PlacementManager 设计支持以下扩展：

1. **自定义得分规则**: 通过 ScoreConfig 配置
2. **特殊方块加成**: 可在 calculateScore 中添加方块类型判断
3. **消除动画**: 返回的 clearedRows/Columns 可用于触发动画
4. **连击系统**: 基于连续消除次数的额外奖励
5. **难度调整**: 动态调整得分配置
